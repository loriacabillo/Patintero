<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Patintero Game</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<style>
html,body { 
height: 100%; 
margin:0; 
padding:0;
}

body {
font-family: "Press Start 2P", cursive;
background: url("patintero-bg.png") no-repeat center center fixed;
background-size: cover;
overflow: hidden;
}

.overlay-card {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 90vw;
max-width: 600px;
background: rgba(0,0,0,0.2);
backdrop-filter: blur(5px);
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
text-align: center;
padding: 5vw;
z-index: 100;
}

.overlay-card h2 {
margin-top: 0;
color: yellow;
font-size: 5vw;
letter-spacing: 2px;
text-shadow: 2px 2px 0 #000;
}

.overlay-card p {
font-size: 3vw;
margin: 5vw 0;
line-height: 1.6em;
color: #fff;
text-shadow: 1px 1px 0 #000;
max-width: 90vw;
}

.overlay-card ul {
text-align: left;
color: #fff;
font-size: 2.5vw;
max-width: 80%;
margin: 2vw 0;
list-style: none;
padding: 0;
}

.overlay-card li {
margin: 1vw 0;
text-shadow: 1px 1px 0 #000;
}

.overlay-card input {
padding: 3vw;
font-size: 3vw;
width: 70%;
margin: 2vw 0;
border: 2px solid #fff;
border-radius: 8px;
background: rgba(255,255,255,0.9);
font-family: inherit;
text-align: center;
}

#startBtn, .submit-btn, #leaderboardBtn {
padding: 3vw 6vw;
font-size: 3vw;
background: #2196f3;
color: #fff;
border: none;
border-radius: 8px;
cursor: pointer;
transition: all 0.18s ease;
box-shadow: 0 4px 0 #0d47a1;
z-index: 101;
pointer-events: auto;
margin: 2vw 0;
}

#leaderboardBtn {
background: #4caf50;
box-shadow: 0 4px 0 #388e3c;
}

#startBtn:hover, .submit-btn:hover, #leaderboardBtn:hover {
transform: scale(1.06);
}

#leaderboardBtn:hover {
background: #45a049;
}

/* UI Elements */
.top-ui {
  position: fixed;
  top: 10px;
  z-index: 1000;
  color: white;
  text-shadow: 1px 1px 0 black;
  font-size: clamp(8px, 2vw, 16px);
  line-height: 1.2;
}

#ui-left {
  left: 10px;
}

#ui-right {
  right: 10px;
  text-align: right;
}

#ui-right h3 {
  color: yellow;
  font-size: clamp(12px, 4vw, 24px);
  margin: 0;
  letter-spacing: 2px;
}

/* Joystick Styles */
#joystick {
  position: fixed;
  bottom: 20px;
  left: 20px;
  width: 100px;
  height: 100px;
  background: rgba(255, 255, 255, 0.3);
  border: 2px solid rgba(255, 255, 255, 0.5);
  border-radius: 50%;
  z-index: 999;
  pointer-events: auto;
  display: none;
  transition: opacity 0.3s ease;
}

#knob {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 40px;
  height: 40px;
  background: rgba(255, 255, 255, 0.7);
  border: 2px solid rgba(255, 255, 255, 0.9);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  transition: transform 0.1s ease;
}

/* Level Complete Announcement */
#levelCompleteOverlay {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 80vw;
  max-width: 400px;
  background: rgba(0, 255, 0, 0.9);
  color: white;
  padding: 20px;
  border-radius: 10px;
  text-align: center;
  z-index: 1001;
  display: none;
  font-size: 4vw;
  font-family: "Press Start 2P", cursive;
  text-shadow: 1px 1px 0 black;
  border: 3px solid yellow;
}

/* Patintero Lines (Visual Aid - Court Width) */
.patintero-line {
  position: fixed;
  left: 10%;
  width: 80%; /* Court width for real Patintero feel */
  height: 4px;
  background: repeating-linear-gradient(
    to right,
    transparent,
    transparent 20px,
    yellow 20px,
    yellow 24px
  );
  opacity: 0.7;
  z-index: 500;
  pointer-events: none;
  display: none;
  border-radius: 2px;
}

/* CHARACTER SPRITE SYSTEM */
:root {
--pixel-size: 2;
}

.Character {
width: calc(32px * var(--pixel-size));
height: calc(32px * var(--pixel-size));
overflow: hidden;
position: absolute;
}

.Character_spritesheet {
animation: moveSpritesheet 1s steps(4) infinite;
width: calc(128px * var(--pixel-size));
position: absolute;
}
.Character_shadow {
position: absolute;
width: calc(32px * var(--pixel-size));
height: calc(32px * var(--pixel-size));
}

.pixelart {
image-rendering: pixelated;
}

.face-down { top: 0; }
.face-right { top: calc(-32px * var(--pixel-size)); }
.face-up { top: calc(-64px * var(--pixel-size)); }
.face-left { top: calc(-96px * var(--pixel-size)); }

@keyframes moveSpritesheet {
from { transform: translate3d(0px,0,0) }
to { transform: translate3d(-100%,0,0) }
}
</style>
</head>
<body>
<!-- Home Screen -->
<div class="overlay-card" id="homeScreen">
<h2>Patintero</h2>
<p>
üèÉ Relive the excitement of a Filipino
childhood favorite! Cross the lines and avoid the taggers.<br><br>
üëâ Use <b>ARROW KEYS / WASD</b> on desktop or <b>VIRTUAL JOYSTICK</b> on mobile to move.<br>
üèÅ Cross above the yellow dashed lines without being tagged!
</p>
<button id="startBtn">‚ñ∂ START GAME</button>
<button id="leaderboardBtn">üèÜ Leaderboard</button>
</div>

<!-- Level Complete Announcement Overlay -->
<div id="levelCompleteOverlay">
  <h2 id="completeMessage">Level Complete!</h2>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
const startBtn = document.getElementById("startBtn");
const leaderboardBtn = document.getElementById("leaderboardBtn");
let playerName = '';
let currentLevel = 1;
let maxLevel = 5;
let gameEnded = false;
let levelCompleted = false; // Flag to prevent multiple triggers per level
let x, y;
let screenW, screenH;
let blockers = [];
let linesY = [];
let lineElements = []; // For visual lines
let inputDisabled = false; // Disable inputs during announcements

// Joystick variables
let joystickActive = false;
let joystickCenterX = 0;
let joystickCenterY = 0;
let currentDx = 0;
let currentDy = 0;
let joystickInterval = null;

// ApiLeaderboard functions (unchanged)
function getLeaderboard() {
  return JSON.parse(localStorage.getItem('patinteroLeaderboard') || '[]');
}

function saveLeaderboard(leaderboard) {
  localStorage.setItem('patinteroLeaderboard', JSON.stringify(leaderboard));
}

function updatePlayerScore(name, levelsCompleted) {
  let lb = getLeaderboard();
  const completed = Math.max(0, levelsCompleted);
  let existing = lb.find(p => p.name.toLowerCase() === name.toLowerCase());
  if (existing) {
    if (completed > existing.levelsCompleted) {
      existing.levelsCompleted = completed;
    }
  } else {
    lb.push({ name: name, levelsCompleted: completed });
  }
  lb.sort((a, b) => b.levelsCompleted - a.levelsCompleted || a.name.localeCompare(b.name));
  saveLeaderboard(lb);
}

function showLeaderboard() {
  const lb = getLeaderboard();
  const top10 = lb.slice(0, 10);
  let html = '<h2>üèÜ Leaderboard</h2><p>Top 10 Players by Levels Completed</p><ul>';
  if (top10.length === 0) {
    html += '<li>No scores yet!</li>';
  } else {
    top10.forEach((p, i) => {
      html += `<li>${i + 1}. ${p.name} - ${p.levelsCompleted} Levels</li>`;
    });
  }
  html += '</ul><button class="submit-btn" id="closeLb">Close</button>';
  const lbOverlay = document.createElement("div");
  lbOverlay.className = "overlay-card";
  lbOverlay.id = "lbOverlay";
  lbOverlay.innerHTML = html;
  document.body.appendChild(lbOverlay);
  document.getElementById("closeLb").addEventListener("click", () => {
    lbOverlay.remove();
  });
}

leaderboardBtn.addEventListener("click", showLeaderboard);

startBtn.addEventListener("click", () => {
  document.getElementById("homeScreen").style.display = "none";

  // Username Input Overlay (unchanged)
  const nameOverlay = document.createElement("div");
  nameOverlay.className = "overlay-card";
  nameOverlay.id = "nameOverlay";
  nameOverlay.innerHTML = `
    <h2>Enter Player Name</h2>
    <p>To start the game, please enter your username.</p>
    <input id="username" type="text" placeholder="Your Name" maxlength="20">
    <button class="submit-btn" id="submitName">‚ñ∂ START GAME</button>
  `;
  document.body.appendChild(nameOverlay);

  const submitNameBtn = document.getElementById("submitName");
  const usernameInput = document.getElementById("username");

  submitNameBtn.addEventListener("click", () => {
    const name = usernameInput.value.trim();
    if (!name) {
      alert("Please enter a username to start the game!");
      return;
    }
    playerName = name;
    localStorage.setItem('patinteroPlayer', JSON.stringify({ name: playerName, currentLevel: currentLevel, maxLevel: maxLevel }));
    nameOverlay.remove();
    initGame();
  });

  usernameInput.addEventListener("keypress", (e) => {
    if (e.key === "Enter") submitNameBtn.click();
  });
});

function updateScreenDimensions() {
  screenW = window.innerWidth;
  screenH = window.innerHeight;
  // Adjusted linesY for better Patintero court fit (lower start, even spacing, avoid sky)
  linesY = [
    screenH * 0.80,  // Level 1: Bottom line
    screenH * 0.65,  // Level 2
    screenH * 0.50,  // Level 3: Middle
    screenH * 0.35,  // Level 4
    screenH * 0.20   // Level 5: Top line (still in court, not sky)
  ];
  // Update visual lines and blockers
  lineElements.forEach((line, i) => {
    if (i < currentLevel) {
      line.style.top = linesY[i] + 'px';
      line.style.display = 'block';
    } else {
      line.style.display = 'none';
    }
  });
  // Reposition existing blockers to new lines
  blockers.forEach((blk, i) => {
    if (i < blockers.length && linesY[i]) {
      blk.style.top = linesY[i] + 'px';
    }
  });
}

// Window resize handler
window.addEventListener('resize', updateScreenDimensions);

function initGame() {
  updateScreenDimensions();
  document.body.style.background = "url('playground.png') no-repeat center center fixed";
  document.body.style.backgroundSize = "cover";

  // UI Elements (unchanged)
  const uiLeft = document.createElement("div");
  uiLeft.id = "ui-left";
  uiLeft.className = "top-ui";
  uiLeft.innerHTML = '<div id="playerInfo"></div>';
  document.body.appendChild(uiLeft);

  const uiRight = document.createElement("div");
  uiRight.id = "ui-right";
  uiRight.className = "top-ui";
  uiRight.innerHTML = '<h3>PATINTERO</h3>';
  document.body.appendChild(uiRight);

  updatePlayerInfo();

  // Create visual patintero lines (court width) - CONTINUATION FROM HERE
  for (let i = 0; i < 5; i++) {
    const line = document.createElement('div');
    line.className = 'patintero-line';
    document.body.appendChild(line);
    lineElements.push(line);
  }

  // Player Sprite (unchanged)
  const player = document.createElement("div");
  player.className = "Character";
  x = screenW * 0.5;
  y = screenH * 0.85;
  player.style.left = x + "px";
  player.style.top = y + "px";
  player.setAttribute("facing", "down");
  player.innerHTML = `
    <img class="Character_shadow pixelart" src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/21542/DemoRpgCharacterShadow.png" />
    <img class="Character_spritesheet pixelart face-down" src="AjFP5.png" />
  `;
  document.body.appendChild(player);

  createBlockersForLevel(currentLevel);

  // Joystick Setup (updated for bounds and speed)
  const joystick = document.createElement('div');
  joystick.id = 'joystick';
  const knob = document.createElement('div');
  knob.id = 'knob';
  joystick.appendChild(knob);
  document.body.appendChild(joystick);

  // Show joystick on touch devices
  if ('ontouchstart' in window) {
    joystick.style.display = 'block';
  }

  // Joystick event handlers
  const joystickElement = document.getElementById('joystick');
  const knobElement = document.getElementById('knob');

  joystickElement.addEventListener('touchstart', (e) => {
    if (gameEnded || inputDisabled) return;
    e.preventDefault();
    joystickActive = true;
    const rect = joystickElement.getBoundingClientRect();
    joystickCenterX = rect.left + rect.width / 2;
    joystickCenterY = rect.top + rect.height / 2;
    updateKnob(e.touches[0].clientX, e.touches[0].clientY);
    startJoystickMovement();
  });

  joystickElement.addEventListener('touchmove', (e) => {
    if (!joystickActive || gameEnded || inputDisabled) return;
    e.preventDefault();
    updateKnob(e.touches[0].clientX, e.touches[0].clientY);
  });

  joystickElement.addEventListener('touchend', (e) => {
    if (gameEnded || inputDisabled) return;
    e.preventDefault();
    joystickActive = false;
    currentDx = 0;
    currentDy = 0;
    knobElement.style.transform = 'translate(-50%, -50%)';
    stopJoystickMovement();
  });

  function updateKnob(touchX, touchY) {
    const deltaX = touchX - joystickCenterX;
    const deltaY = touchY - joystickCenterY;
    const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    const maxDist = 30;

    let normalizedDx = 0;
    let normalizedDy = 0;

    if (dist > maxDist) {
      const angle = Math.atan2(deltaY, deltaX);
      const clampedX = Math.cos(angle) * maxDist;
      const clampedY = Math.sin(angle) * maxDist;
      normalizedDx = clampedX / maxDist;
      normalizedDy = clampedY / maxDist;
      knobElement.style.transform = `translate(-50%, -50%) translate(${clampedX}px, ${clampedY}px)`;
    } else {
      normalizedDx = deltaX / maxDist;
      normalizedDy = deltaY / maxDist;
      knobElement.style.transform = `translate(-50%, -50%) translate(${deltaX}px, ${deltaY}px)`;
    }

    currentDx = normalizedDx;
    currentDy = normalizedDy;
  }

  function startJoystickMovement() {
    if (joystickInterval) clearInterval(joystickInterval);
    joystickInterval = setInterval(() => {
      if (!joystickActive || gameEnded || inputDisabled) {
        stopJoystickMovement();
        return;
      }
      moveBasedOnJoystick();
    }, 120); // Responsive interval
  }

  function stopJoystickMovement() {
    if (joystickInterval) {
      clearInterval(joystickInterval);
      joystickInterval = null;
    }
  }

  function moveBasedOnJoystick() {
    if (!joystickActive || gameEnded || inputDisabled) return;

    const threshold = 0.3;
    let dx = 0, dy = 0, direction = 'face-down';

    if (Math.abs(currentDx) > threshold || Math.abs(currentDy) > threshold) {
      // Prioritize vertical for Patintero crossing
      if (Math.abs(currentDy) > Math.abs(currentDx)) {
        if (currentDy < -threshold) {
          dy = -25; // Speed for easier upper-level crossing
          direction = 'face-up';
        } else if (currentDy > threshold) {
          dy = 25;
          direction = 'face-down';
        }
      } else {
        if (currentDx < -threshold) {
          dx = -25;
          direction = 'face-left';
        } else if (currentDx > threshold) {
          dx = 25;
          direction = 'face-right';
        }
      }
      movePlayer(dx, dy, direction);
    }
  }

  // === PLAYER MOVEMENT ===
  gameEnded = false;

  function movePlayer(dx, dy, direction) {
    if (gameEnded || inputDisabled) return;
    x += dx;
    y += dy;
    // Bounds (full screen, but can be court-limited if needed)
    const playerSize = 64;
    x = Math.max(0, Math.min(screenW - playerSize, x));
    y = Math.max(0, Math.min(screenH - playerSize, y));
    const sprite = player.querySelector(".Character_spritesheet");
    sprite.className = `Character_spritesheet pixelart ${direction}`;
    player.style.left = x + "px";
    player.style.top = y + "px";
  }

  // Keyboard controls (desktop/laptop)
  window.addEventListener("keydown", e => {
    if (gameEnded || inputDisabled) return;
    // Prevent default to avoid scrolling on laptop
    e.preventDefault();
    if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") movePlayer(-25, 0, "face-left");
    if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") movePlayer(25, 0, "face-right");
    if (e.key === "ArrowUp" || e.key.toLowerCase() === "w") movePlayer(0, -25, "face-up");
    if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") movePlayer(0, 25, "face-down");
  });

  // Level Complete Announcement Function
  function showLevelComplete() {
    inputDisabled = true;
    levelCompleted = true; // Prevent multiple triggers
    const overlay = document.getElementById('levelCompleteOverlay');
    const messageEl = document.getElementById('completeMessage');
    messageEl.textContent = `Level ${currentLevel} Complete!`;
    overlay.style.display = 'block';

    setTimeout(() => {
      overlay.style.display = 'none';
      inputDisabled = false;
      // Proceed to next level
      currentLevel++;
      levelCompleted = false; // Reset flag
      x = screenW * 0.5;
      y = screenH * 0.85;
      player.style.left = x + "px";
      player.style.top = y + "px";
      createBlockersForLevel(currentLevel);
      updatePlayerInfo();
      updateScreenDimensions(); // Recalculate for new level
      gameEnded = false;
    }, 2000); // 2 seconds visibility
  }

  // === BLOCKER CHASE + GAME OVER ===
  setInterval(() => {
    if (gameEnded || inputDisabled || levelCompleted) return;

    const playerX = x;
    let tagged = false;

    // Court bounds for blockers (real Patintero: 10%-90% width patrol)
    const courtLeft = screenW * 0.1;
    const courtRight = screenW * 0.9;
    const blockerStep = 20;

    blockers.forEach(blk => {
      const blockerX = parseInt(blk.style.left);
      const blockerY = parseInt(blk.style.top);
      const dx = playerX - blockerX;
      const dy = y - blockerY;

      let newBlockerX = blockerX;

      // Horizontal movement only (chase player x)
      if (Math.abs(dx) > blockerStep) {
        newBlockerX = blockerX + blockerStep * Math.sign(dx);
      }

      // Enforce bounds (stay on court, bounce at edges like real taggers)
      if (newBlockerX < courtLeft) newBlockerX = courtLeft + (courtLeft - newBlockerX); // Simple bounce
      if (newBlockerX > courtRight - 64) newBlockerX = (courtRight - 64) - (newBlockerX - (courtRight - 64));

      blk.style.left = newBlockerX + "px";
      blk.style.top = blockerY + "px"; // Fixed on line

      // Face player
      let faceDir = (dx > 0) ? "face-right" : "face-left"; // Prioritize horizontal
      if (Math.abs(dy) > Math.abs(dx)) {
        faceDir = (dy > 0) ? "face-down" : "face-up";
      }
      const sprite = blk.querySelector(".Character_spritesheet");
      sprite.className = `Character_spritesheet pixelart ${faceDir}`;

      // Collision (after move)
      const distanceX = Math.abs(playerX - newBlockerX);
      const distanceY = Math.abs(y - blockerY);
      const collisionThreshold = 40;

      if (distanceX < collisionThreshold && distanceY < collisionThreshold) {
        tagged = true;
      }
    });

    if (tagged) {
      gameEnded = true;
      updatePlayerScore(playerName, currentLevel - 1);
      const gameOver = document.createElement("div");
      gameOver.className = "overlay-card";
      gameOver.id = "gameOverOverlay";
      gameOver.innerHTML = `
        <h2>üòµ GAME OVER!</h2>
        <p>You were tagged at Level ${currentLevel}! (Completed: ${Math.max(0, currentLevel - 1)} levels)</p>
        <button class="submit-btn" onclick="location.reload()">üîÅ Restart</button>
        <button id="viewLbAfter" class="submit-btn">üèÜ View Leaderboard</button>
      `;
      document.body.appendChild(gameOver);
      document.getElementById("viewLbAfter")?.addEventListener("click", () => {
        const gameOverEl = document.getElementById("gameOverOverlay");
        if (gameOverEl) gameOverEl.style.display = "none";
        showLeaderboard();
      });
      return;
    }

    // ‚úÖ Finish line check: Improved for levels 3-5 (laptop reliability)
    const lastLineY = linesY[currentLevel - 1];
    const playerSize = 64;
    const buffer = 32; // Relaxed buffer for upper lines
    // Check if player's bottom is fully above the line (no prevY dependency to avoid skips)
    if (y + playerSize < lastLineY - buffer && !levelCompleted && !gameEnded) {
      // console.log(`Triggering Level ${currentLevel} Complete! Player bottom: ${y + playerSize}, Line: ${lastLineY}`); // Debug log
      gameEnded = true;
      if (currentLevel < maxLevel) {
        showLevelComplete();
      } else {
        // Final win
        updatePlayerScore(playerName, maxLevel);
        const winScreen = document.createElement("div");
        winScreen.className = "overlay-card";
        winScreen.id = "winOverlay";
        winScreen.innerHTML = `
          <h2>üéâ YOU WIN!</h2>
          <p>You completed all ${maxLevel} levels!</p>
          <button class="submit-btn" onclick="location.reload()">üîÅ Play Again</button>
          <button id="viewLbWin" class="submit-btn">üèÜ View Leaderboard</button>
        `;
        document.body.appendChild(winScreen);
        document.getElementById("viewLbWin")?.addEventListener("click", () => {
          const winEl = document.getElementById("winOverlay");
          if (winEl) winEl.style.display = "none";
          showLeaderboard();
        });
      }
    }
  }, 150); // Faster interval for precise detection on higher levels/laptops
}

function createBlockersForLevel(level) {
  // Remove existing blockers
  blockers.forEach(blk => blk.remove());
  blockers = [];

  // Court bounds for initial positions
  const courtLeft = screenW * 0.1;
  const courtRight = screenW * 0.9 - 64;

  for (let i = 0; i < level; i++) {
    const blocker = document.createElement("div");
    blocker.className = "Character";
    // Randomized start x within court (fits lines better)
    const startX = courtLeft + (Math.random() * (courtRight - courtLeft));
    blocker.style.left = startX + "px";
    blocker.style.top = linesY[i] + "px"; // Fixed on line
    blocker.setAttribute("facing", "down");
    blocker.innerHTML = `
      <img class="Character_shadow pixelart" src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/21542/DemoRpgCharacterShadow.png" />
      <img class="Character_spritesheet pixelart face-down" src="blocker.png" />
    `;
    document.body.appendChild(blocker);
    blockers.push(blocker);
  }

  // Update visual lines (only up to current level)
  lineElements.forEach((line, i) => {
    if (i < level) {
      line.style.top = linesY[i] + 'px';
      line.style.display = 'block';
    } else {
      line.style.display = 'none';
    }
  });
}

function updatePlayerInfo() {
  const playerInfo = document.getElementById("playerInfo");
  if (playerInfo) {
    playerInfo.innerHTML = `${playerName}<br>Level ${currentLevel}/${maxLevel}`;
  }
}
});
</script>
</body>
</html>

      